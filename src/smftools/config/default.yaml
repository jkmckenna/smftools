# General
sample_sheet_path: null # path to sample_sheet to load metadata into anndata.
sample_sheet_mapping_column: 'Experiment_name_and_barcode' # The column in the sample sheet and current anndata to use for mapping metadata.
sample_name_col_for_plotting: 'Experiment_name_and_barcode'

# Compute params
threads: 4
device: "auto"

######## smftools load params #########
# Generic i/o
recursive_input_search: True
strands:
  - bottom
  - top
conversions:
  - unconverted
fastq_barcode_map: null # For FASTQ files, an optional map of file paths to barcodes can be provided. Default is autodetecting barcodes.
fastq_auto_pairing: True # For FASTQ files, attempt to find read pair files automatically.
input_already_demuxed: False # If the input files are already demultiplexed.

delete_intermediate_hdfs: True # Whether to delete the intermediate hdfs from the conversion/deamination workflows.
delete_intermediate_bams: False # Whether to delete intermediate BAM files.
delete_intermediate_tsvs: False # Whether to delete intermediate TSV files.

# Sequencing modality and general experiment params
smf_modality: 'conversion' # conversion, deaminase, direct
sequencer: 'ont' # ont, pacbio, illumina
barcode_kit: 'SQK-RBK114-96' # SQK-RBK114-96, SQK-NBD114-24, etc
mod_target_bases:
  - "GpC"
  - "CpG"
enzyme_target_bases:
  - "GpC"

# Nanopore specific basecalling params
model_dir: null # Directory where dorado basecalling models are stored.
model: "hac" # needed for dorado basecaller
filter_threshold: 0.8 # Dorado probability filter threshold for base calling.
emit_moves: True # Whether to emit move tables (mv tag) during basecalling for signal-to-base alignment

# Alignment params
aligner: "dorado" # Aligner to use: dorado, minimap2
align_from_bam: False # Whether to run alignment from a bam file for minimap2. If False, runs alignment from a FASTQ file.
aligner_args:
  minimap2:
    ont:
      - '-a'
      - '-x'
      - 'map-ont'
      - '--MD'
      - '-Y' 
      - '-y'
      - '-N'
      - '5'
    pacbio:
      - '-a'
      - '-x'
      - 'map-hifi'
      - '--MD'
      - '-Y' 
      - '-y'
      - '-N'
      - '5'
    illumina:
      - '-a'
      - '-x'
      - 'sr'
      - '--MD'
      - '-Y' 
      - '-y'
      - '-N'
      - '5'
  dorado:
    ont:
      - "--mm2-opts"
      - "-N 5"

# Sorted BAM and BED specific handling
make_bigwigs: False # Whether to make coverage bigwigs
make_beds: False # Whether to make beds from the aligned bams
annotate_secondary_supplementary: True # Whether to annotate reads with secondary/supplementary alignments from the aligned BAM
samtools_backend: auto # auto|python|cli for samtools-compatible operations
bedtools_backend: auto # auto|python|cli for bedtools-compatible operations
bigwig_backend: auto # auto|python|cli for bedGraphToBigWig conversion

# Nanopore specific demultiplexing
demux_backend: dorado # smftools|dorado - smftools uses YAML-based barcode refs, dorado uses kit names
barcode_both_ends: False # Require barcode match at both ends
trim: False # dorado adapter and barcode removal during demultiplexing
use_umi: False # Whether to detect and annotate UMIs in aligned_sorted BAM before demultiplexing
umi_length: null # Length of each UMI (required when use_umi is true)
umi_min_entropy: 1.65 # Minimum Shannon entropy (bits) for U1/U2 pass status in preprocess
umi_cluster_max_edit_distance: 2 # Max edit distance for UMI clustering within sample+reference groups
umi_search_window: 200 # Max distance from read ends to consider an adapter match for UMI extraction
umi_adapter_matcher: edlib # exact|edlib
umi_adapter_max_edits: null # Used for edlib fuzzy matching; null defers to UMI YAML/default

# smftools barcode extraction (when demux_backend: smftools)
# barcode_kit can be: alias from BARCODE_KIT_ALIASES in constants.py, or "custom" (requires custom_barcode_yaml)
custom_barcode_yaml: null # Path to YAML file containing barcode name -> sequence mappings (when barcode_kit: custom)
barcode_adapters: [null, null] # Two-slot list [left_ref_end_adapter, right_ref_end_adapter]
barcode_search_window: 200 # Max distance from read ends to search for adapter
barcode_max_edit_distance: null # Max edit distance for matching extracted barcode to references; null defers to YAML/default
barcode_adapter_matcher: edlib # exact|edlib for adapter detection
barcode_composite_max_edits: null # Max edits for composite or single-flank matching; null defers to YAML/default
barcode_min_separation: null # Min distance between best and second-best barcode match; null disables
barcode_min_score: null # Optional minimum score threshold for barcode assignment

# Barcode flanking configuration
barcode_ends: null  # both | read_start | read_end | left_only | right_only - null defers to YAML/default
barcode_amplicon_gap_tolerance: 5  # Allowed gap/overlap (bp) between amplicon and barcode; null defers to YAML/default

# UMI flanking configuration
umi_ends: null  # both | left_only | right_only - null defers to YAML/default
umi_flank_mode: null  # adapter_only | amplicon_only | both - null defers to YAML/default
umi_amplicon_max_edits: null
umi_kit: null  # UMI kit alias (e.g. "dual-nextera-12") or "custom" with umi_yaml
umi_yaml: null  # Path to UMI YAML config file (when umi_kit: custom)

skip_bam_split: False # Skip BAM splitting/demux step and load AnnData directly from the aligned/sorted BAM.

# Anndata structure
mapping_threshold: 0.10 # Minimum proportion of mapped reads that need to fall within a region to include in the final AnnData.
reference_column: 'Reference_strand'
sample_column: 'Experiment_name_and_barcode'

# Plotting params
clustermap_demux_types_to_plot: 
  - "single"
  - "double"
  - "already"

######## smftools preprocess params #########
# Read length, quality, and mapping filtering params
read_coord_filter:
 - null
 - null
# Actual read-length filter on adata.obs['read_length']
read_len_filter_thresholds:
  - null
  - null
# Mapped-length filter on adata.obs['mapped_length']
mapped_len_filter_thresholds:
  - 100
  - null
# Actual read-length/reference-length ratio filter on adata.obs['read_length_to_reference_length_ratio']
read_len_to_ref_ratio_filter_thresholds:
  - null
  - null
# Mapped-length/reference-length ratio filter on adata.obs['mapped_length_to_reference_length_ratio']
mapped_len_to_ref_ratio_filter_thresholds:
  - null
  - null
# Mapped-length/read-length ratio filter on adata.obs['mapped_length_to_read_length_ratio']
mapped_len_to_read_len_ratio_filter_thresholds:
  - null
  - null
read_quality_filter_thresholds:
  - 10
  - null
read_mapping_quality_filter_thresholds:
  - null
  - null

# Read modification filtering params
read_mod_filtering_gpc_thresholds:
  - 0.025
  - 0.975
read_mod_filtering_cpg_thresholds:
  - 0.0
  - 1.0
read_mod_filtering_c_thresholds:
  - 0.025
  - 0.975
read_mod_filtering_a_thresholds:
  - 0.025
  - 0.975
read_mod_filtering_use_other_c_as_background: False
min_valid_fraction_positions_in_read_vs_ref: 0.2

# Plotting params for read length histograms
obs_to_plot_pp_qc:
  - read_length
  - mapped_length
  - read_quality
  - mapping_quality
  - mapped_length_to_reference_length_ratio
  - mapped_length_to_read_length_ratio
  - Raw_modification_signal

# Duplicate detection params
duplicate_detection_site_types: # Site types to consider for duplicate detection workflow
  - "GpC"
  - "CpG"
  - "ambiguous_GpC_CpG"
duplicate_detection_distance_threshold: 0.07 # Hamming distance based similarity threshold to use for marking duplicate reads.
duplicate_detection_demux_types_to_use: 
  - "single"
  - "double"
  - "already"
hamming_vs_metric_keys: # Metrics to plot the hamming distance against.
  - Fraction_C_site_modified
duplicate_detection_keep_best_metric: "read_quality" # Obs metric to use to keep a representative read from a read duplicate cluster
duplicate_detection_window_size_for_hamming_neighbors: 50 # How many neighboring reads to look at for calculating hamming distance pairs
duplicate_detection_min_overlapping_positions: 20 # The minimum amount of valid overlapping positions that will allow duplicate detection to work
duplicate_detection_do_hierarchical: True # Whether to follow up fwd/rev lexicographic duplicate detection with hieratchical clustering based method
duplicate_detection_hierarchical_linkage: "average" # Method for hierarchical clustering distance calculation
duplicate_detection_do_pca: False # Whether to do PCA before hierarchical linkage based duplicate detection.

# Position QC params
position_max_nan_threshold: 0.8 # The maximum amount of nans to tolerate in a column
mismatch_frequency_range:
  - 0.01
  - 0.99
mismatch_frequency_layer: "mismatch_integer_encoding"
mismatch_frequency_read_span_layer: "read_span_mask"
mismatch_base_frequency_exclude_mod_sites: True

######## smftools spatial params #########
invert_adata: False # Whether to invert the AnnData along the positions axis.
# Reindexing params
reindexing_offsets:
  null : null
reindexed_var_suffix: "reindexed"

# Spatial Analysis - QC Plotting params
rows_per_qc_histogram_grid: 12

# Spatial Analysis - Clustermap params
layer_for_clustermap_plotting: 'nan0_0minus1'
clustermap_cmap_c: "coolwarm"
clustermap_cmap_gpc: "coolwarm"
clustermap_cmap_cpg: "coolwarm"
clustermap_cmap_a: "coolwarm"
spatial_clustermap_sortby: "gpc"

# Clustermap variant params
overlay_variant_calls: false
variant_overlay_seq1_color: "black"
variant_overlay_seq2_color: "white"
variant_overlay_marker_size: 4.0

# Spatial analysis - Rolling NN Hamming
rolling_nn_layer: "nan0_0minus1"
rolling_nn_plot_layer: "nan0_0minus1"
rolling_nn_plot_layers:
  - "nan0_0minus1"
  - "zero_hamming_distance_spans"
rolling_nn_window: 10
rolling_nn_step: 1
rolling_nn_min_overlap: 8
rolling_nn_return_fraction: true
rolling_nn_obsm_key: "rolling_nn_dist"
rolling_nn_site_types: 
  - "GpC"
  - "CpG"
rolling_nn_write_zero_pairs_csvs: true
rolling_nn_zero_pairs_uns_key: null
rolling_nn_zero_pairs_segments_key: null
rolling_nn_zero_pairs_layer_key: null
rolling_nn_zero_pairs_refine: true
rolling_nn_zero_pairs_max_nan_run: 2
rolling_nn_zero_pairs_merge_gap: 1
rolling_nn_zero_pairs_max_segments_per_read: 2
rolling_nn_zero_pairs_max_overlap: 5
rolling_nn_zero_pairs_layer_overlap_mode: "sum"
rolling_nn_zero_pairs_layer_overlap_value: null
rolling_nn_zero_pairs_keep_uns: true
rolling_nn_zero_pairs_segments_keep_uns: true
rolling_nn_zero_pairs_top_segments_per_read: 3
rolling_nn_zero_pairs_top_segments_max_overlap: 5
rolling_nn_zero_pairs_top_segments_min_span: 300
rolling_nn_zero_pairs_top_segments_write_csvs: true
rolling_nn_zero_pairs_segment_histogram_bins: 30

# Cross-sample rolling NN analysis
cross_sample_analysis: true
cross_sample_grouping_col: null
cross_sample_random_seed: 42
delta_hamming_chimeric_span_threshold: 200

# Latent Analysis - UMAP/Leiden params
layer_for_umap_plotting: 'nan_half'
umap_layers_to_plot:
  - "leiden"
  - "mapped_length"
  - "Raw_modification_signal"

# Spatial Analysis - Spatial Autocorrelation params
autocorr_normalization_method: "pearson" # options are pearson or sum
rows_per_qc_autocorr_grid: 6
autocorr_rolling_window_size: 25
autocorr_max_lag: 800
autocorr_site_types:
  - "GpC"

# Spatial Analysis - Correlation Matrix params
correlation_matrix_types:
  - "pearson"
  - "binary_covariance"
correlation_matrix_cmaps:
  - "seismic"
  - "viridis"
correlation_matrix_site_types:
  - "GpC_site"

######## smftools hmm params #########
# HMM params
hmm_n_states: 2 # Number of HMM states
hmm_init_emission_probs:
  - [0.8, 0.2]
  - [0.2, 0.8] 
hmm_init_transition_probs: 
  - [0.9, 0.1]
  - [0.1, 0.9]
hmm_init_start_probs: 
  - 0.5
  - 0.5
hmm_eps: 1e-8
# Fitting strategy
hmm_fit_strategy: "per_group"      # "per_group" | "shared_transitions"
hmm_shared_scope: ["reference", "methbase"]
hmm_groupby: ["sample", "reference", "methbase"]
# If hmm_fit_strategy == shared_transitions
hmm_adapt_emissions: true
hmm_adapt_startprobs: true
hmm_emission_adapt_iters: 5
hmm_emission_adapt_tol: 1.0e-4
hmm_dtype: "float64"
hmm_annotation_threshold: 0.5 # The minimum probability threshold of a feature interval to accept it for layer annotation.
hmm_batch_size: 1024 # hmm batch size
hmm_use_viterbi: False # Whether to use viterbi decoding. If False, uses forward-backward gammas. Viterbi is smoother, but less sensitive.
footprints: True # whether to use the default HMM footprint params
accessible_patches: True # whether to use the default HMM accessible patch params
cpg: False # whether to use the default HMM endogenous CpG patch params
hmm_methbases:
  - "GpC"
  - "CpG"
  - "C"
  - "A"
hmm_feature_sets:
  footprint:
    state: "Non-Modified"
    features:
      small_bound_stretch: [6, 40]
      medium_bound_stretch: [40, 100]
      putative_nucleosome: [100, 200]
      large_bound_stretch: [200, inf]
  accessible:
    state: "Modified"
    features:
      small_accessible_patch: [3, 20]
      mid_accessible_patch: [20, 40]
      large_accessible_patch: [40, 110]
      nucleosome_depleted_region: [110, inf]
hmm_feature_colormaps:
  small_accessible_patch: "#A5D6A7"
  mid_accessible_patch: "#2E7D32"
  large_accessible_patch: "#006400"
  nucleosome_depleted_region: "#00441B"
  all_accessible_features: "#2E7D32"
  small_bound_stretch: "#1E88E5"
  medium_bound_stretch: "#6A1B9A"
  large_bound_stretch: "#FB8C00"
  putative_nucleosome: "#6D4C41"
  all_footprint_features: "#6A1B9A"
  cpg_patch: "#6D4C41"
hmm_merge_layer_features:
  - ["all_accessible_features", 60]
clustermap_cmap_hmm: "coolwarm"
hmm_clustermap_feature_layers:
  - nucleosome_depleted_region_merged
  - small_bound_stretch
  - medium_bound_stretch
  - putative_nucleosome
hmm_clustermap_length_layers:
  - all_accessible_features_merged
  - all_footprint_features
hmm_clustermap_sortby: "hmm"
hmm_peak_feature_configs:
  all_accessible_features:
    min_distance: 200 # The minimum distance in between called peaks
    peak_width: 200 # The window width to calculate sum/mean hmm signal per read centered at the peak center.
    peak_prominence: 0.1 # The minimum prominence to call a peak
    peak_threshold: 0.80 # The minimum mean hmm signal in each molecule within the peak window to mark the molecule as positive for the feature.
    rolling_window: 50 # Window size for the rolling average smoothing before peak calling

  all_accessible_features_merged:
    min_distance: 250
    peak_width: 250
    peak_prominence: 0.05
    peak_threshold: 0.80
    rolling_window: 50 

  small_accessible_patch:
    min_distance: 40
    peak_width: 30
    peak_prominence: 0.1
    peak_threshold: 0.8
    rolling_window: 40 

  mid_accessible_patch:
    min_distance: 100
    peak_width: 60
    peak_prominence: 0.025
    peak_threshold: 0.80
    rolling_window: 50 

  large_accessible_patch:
    min_distance: 100
    peak_width: 100
    peak_prominence: 0.025
    peak_threshold: 0.80
    rolling_window: 50 

  nucleosome_depleted_region:
    min_distance: 200
    peak_width: 200
    peak_prominence: 0.025
    peak_threshold: 0.80
    rolling_window: 50 

  small_bound_stretch:
    min_distance: 20
    peak_width: 20
    peak_prominence: 0.01
    peak_threshold: 0.50
    rolling_window: 10 

  medium_bound_stretch:
    min_distance: 40
    peak_width: 40
    peak_prominence: 0.01
    peak_threshold: 0.50
    rolling_window: 20 

  putative_nucleosome:
    min_distance: 160
    peak_width: 147     # canonical nucleosome footprint
    peak_prominence: 0.025
    peak_threshold: 0.60
    rolling_window: 20 

  large_bound_stretch:
    min_distance: 250
    peak_width: 300
    peak_prominence: 0.20
    peak_threshold: 0.80
    rolling_window: 50 

# Pipeline control flow - load adata
force_redo_load_adata: False # Whether to perform load adata command from start

# Pipeline control flow - Preprocessing and QC
force_redo_preprocessing: False # Whether to force redo the entire preprocessing workflow from the initial raw anndata.
force_reload_sample_sheet: True # Whether to force redo sample sheet loading
bypass_add_read_length_and_mapping_qc: False # Whether to skip read length, quality, and mapping qc.
force_redo_add_read_length_and_mapping_qc: False # Whether to force redo read length, quality, and mapping qc.
bypass_clean_nan: False # Whether to skip NaN cleaning
force_redo_clean_nan: False # Whether to redo NaN cleaning
bypass_append_base_context: False # Whether to skip adding per reference base context additions.
force_redo_append_base_context: False # Whether to redo per reference base context additions.
bypass_append_binary_layer_by_base_context: False # Whether to skip adding new binary layers for each specific base context.
force_redo_append_binary_layer_by_base_context: False # Whether to redo adding new binary layers for each specific base context.
bypass_calculate_read_modification_stats: False # Whether to skip adding read level modification statistics.
force_redo_calculate_read_modification_stats: False # Whether to force redo adding read level modification statistics.
bypass_filter_reads_on_modification_thresholds: False # Whether to skip filtering reads based on read level modification statistics.
force_redo_filter_reads_on_modification_thresholds: False # Whether to redo filtering reads based on read level modification statistics.
bypass_flag_duplicate_reads: False # Whether to skip flagging duplicate reads based on modification similarity.
force_redo_flag_duplicate_reads: False # Whether to redo flagging duplicate reads based on modification similarity.
bypass_complexity_analysis: False # Whether to skip complexity analysis
force_redo_complexity_analysis: False # Whether to redo complexity analysis

# Pipeline control flow - Spatial Analyses
force_redo_spatial_analyses: False # Whether to force redo the entire basic analysis pipeline from the AnnData
bypass_basic_clustermaps: False # Whether to skip basic clustermap plotting
force_redo_basic_clustermaps: False # Whether to redo basic clustermap plotting
bypass_basic_umap: False # Whether to skip basic UMAP calculation/plotting
force_redo_basic_umap: False # Whether to redo basic UMAP calculation/plotting
bypass_spatial_autocorr_calculations: False # Whether to skip basic spatial autocorrelation calculation
force_redo_spatial_autocorr_calculations: False # Whether to redo basic spatial autocorrelation calculation
bypass_spatial_autocorr_plotting: False # Whether to skip basic spatial autocorrelation plotting
force_redo_spatial_autocorr_plotting: False # Whether to redo basic spatial autocorrelation plotting
bypass_matrix_corr_calculations: False # Whether to skip basic correlation matrix calculation
force_redo_matrix_corr_calculations: False # Whether to force redo basic correlation matrix calculation
bypass_matrix_corr_plotting: False # Whether to skip basic correlation matrix plotting
force_redo_matrix_corr_plotting: False # Whether to force redo basic correlation matrix calculation

# Pipeline control flow - HMMs
bypass_hmm_fit: False # Whether to skip HMM fitting for each sample/reference
force_redo_hmm_fit: False # Whether to redo HMM fitting for each sample/reference
bypass_hmm_apply: False # Whether to skip HMM application for each sample/reference
force_redo_hmm_apply: False # Whether to redo HMM application for each sample/reference
